<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Automata | cormullion</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="Automata" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="To play along with this post, you’ll be able to find the source on github, and you’ll need Julia (version 1), and the packages Luxor, Colors, and ColorSchemes. This post was written using Fredrik Ekre’s Literate.jl." />
<meta property="og:description" content="To play along with this post, you’ll be able to find the source on github, and you’ll need Julia (version 1), and the packages Luxor, Colors, and ColorSchemes. This post was written using Fredrik Ekre’s Literate.jl." />
<link rel="canonical" href="http://localhost:4000/blog/2018/11/29/automata.html" />
<meta property="og:url" content="http://localhost:4000/blog/2018/11/29/automata.html" />
<meta property="og:site_name" content="cormullion" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-11-29T00:00:00+00:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/blog/2018/11/29/automata.html","headline":"Automata","dateModified":"2018-11-29T00:00:00+00:00","datePublished":"2018-11-29T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/2018/11/29/automata.html"},"description":"To play along with this post, you’ll be able to find the source on github, and you’ll need Julia (version 1), and the packages Luxor, Colors, and ColorSchemes. This post was written using Fredrik Ekre’s Literate.jl.","@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="cormullion" /></head>
<body><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

<p class="homebutton"><a href="https://cormullion.github.io">home</a></p>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Automata</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-11-29T00:00:00+00:00" itemprop="datePublished">29 November 2018
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <blockquote>
  <p>To play along with this post, you’ll be able to find the source on <a href="https://github.com/cormullion/cormullion.github.io">github</a>, and you’ll need Julia (version 1), and the packages Luxor, Colors, and ColorSchemes. This post was written using Fredrik Ekre’s <a href="https://github.com/fredrikekre/Literate.jl" target="_blank">Literate.jl</a>.</p>
</blockquote>

<blockquote>
  <p>I don’t need to give you any references—you’ll be spoilt for choice if you start googling.</p>
</blockquote>

<p>Here in the UK we’re usually better at closing railway stations than opening new ones. Dr Beeching famously closed thousands of them (more than 50% of the total) in the 1960s. Occasionally, though, new stations are built, and one recent addition to the rail network is the station at <a href="https://www.networkrail.co.uk/running-the-railway/our-routes/anglia/cambridge-north-station/" target="_blank">Cambridge North</a>, built mainly to serve the Cambridge Science Park. (I used to walk along the railway tracks there at weekends before the old disused line was re-opened, but that’s another story…)</p>

<p>When the station was opened, in 2017, there was a bit of chatter about the decorative panels used for the building.</p>

<p><img src="/images/automata/Cmglee_Cambridge_North_front_night.jpg" alt="image label" /></p>

<p>(Image by <a href="https://commons.wikimedia.org/wiki/File:Cmglee_Cambridge_North_front_night.jpg" target="_blank">cmglee at wikipedia</a>, licensed CC-SA)</p>

<p>Thsee patterns were described by the designers at Atkins (the contractors) like this:</p>

<blockquote>
  <p>The station is wrapped in three equal bands of aluminium panels which have been perforated with a design derived from John Horton Conway’s “Game of Life” theories which he established while at Gonville and Caius College, Cambridge in 1970. These beautiful, delicate panels ensure passive security to ground floor glazed areas, assist with wayfinding while crossing the footbridge and allow the building to transform its appearance between day and night through sensitive backlighting.</p>
</blockquote>

<p>This quote is from the original article (<a href="https://web.archive.org/web/20170219171551/https://www.atkinsglobal.com/en-GB/projects/cambridge-north-station" target="_blank">archived here</a>), but it’s since been corrected, most probably in response to the anguished cries of thousands of Cambridge nerds who swiftly pointed out that, in fact, these patterns weren’t <em>Life</em> as we know it, but were actually one-dimensional cellular automata, and so linked, not so much with Cambridge’s John Horton Conway, as with noted Oxford/CalTech alumnus Stephen “Mr Mathematica” Wolfram.</p>

<p>I think the designers did a great job using these simple graphics to “create a harmonic relationship with the scientific research and industry of the Cambridge Colleges and nearby Science Park”.</p>

<h3 id="so-what-is-a-one-dimensional-cellular-automaton">So what is a one-dimensional cellular automaton?</h3>

<p>A cellular automaton is a mathematical model that creates patterns automatically according to simple rules. In its simplest, one-dimensional form, it’s a row of empty squares, each of which can be occupied or empty. The rules for the model determine how sensitive the occupants of each square are to their immediate left and right neighbours, and whether, after some unspecified time, they survive or die. Sometimes empty squares can miraculously become occupied. Because a square has just two immediate neighbours, there are 8 different cases to consider, ranging from all empty (“□□□” or <code class="highlighter-rouge">000</code> in binary) to all full (“■■■” or <code class="highlighter-rouge">111</code>).</p>

<p>The rule determines how one generation changes to the next by specifying the outcome for each of the 8 cases. So, for example, an empty square surrounded by empty neighbours can continue to be empty (false, or 0), or it can produce a new occupant in the next generation, (true, or 1). There are 256 different combinations, since each of the 8 cases can be either 0 or 1.</p>

<p>The wikipedia has <a href="https://commons.wikimedia.org/wiki/File:One-d-cellular-automate-rule-30.gif" target="_blank">this nice animation</a> showing how the rule produces the next generation of squares.</p>

<p><img src="/images/automata/one-d-cellular-automaton-rule-110.gif" alt="image label" /></p>

<p>(Well, it has this nice animation now…)</p>

<h3 id="first-steps">First steps</h3>

<p>To explore these simple automata, I started (<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>) by making a Julia structure:</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="n">mutable</span> <span class="n">struct</span> <span class="n">CA</span>
    <span class="n">rule</span><span class="o">::</span><span class="kt">Int64</span>
    <span class="n">cells</span><span class="o">::</span><span class="n">BitArray</span><span class="x">{</span><span class="mi">1</span><span class="x">}</span>
    <span class="n">colorstops</span><span class="o">::</span><span class="n">Array</span><span class="x">{</span><span class="kt">Float64</span><span class="x">,</span> <span class="mi">1</span><span class="x">}</span>
    <span class="n">ruleset</span><span class="o">::</span><span class="n">BitArray</span><span class="x">{</span><span class="mi">1</span><span class="x">}</span>
    <span class="n">generation</span><span class="o">::</span><span class="kt">Int64</span>
    <span class="k">function</span><span class="nf"> CA</span><span class="x">(</span><span class="n">rule</span><span class="x">,</span> <span class="n">ncells</span> <span class="o">=</span> <span class="mi">100</span><span class="x">)</span>
        <span class="n">cells</span>                    <span class="o">=</span> <span class="n">falses</span><span class="x">(</span><span class="n">ncells</span><span class="x">)</span>
        <span class="n">colorstops</span>               <span class="o">=</span> <span class="n">zeros</span><span class="x">(</span><span class="kt">Float64</span><span class="x">,</span> <span class="n">ncells</span><span class="x">)</span>
        <span class="n">ruleset</span>                  <span class="o">=</span> <span class="n">binary_to_array</span><span class="x">(</span><span class="n">rule</span><span class="x">)</span>
        <span class="n">cells</span><span class="x">[</span><span class="n">length</span><span class="x">(</span><span class="n">cells</span><span class="x">)</span> <span class="n">÷</span> <span class="mi">2</span><span class="x">]</span> <span class="o">=</span> <span class="n">true</span>
        <span class="n">generation</span>               <span class="o">=</span> <span class="mi">1</span>
        <span class="nb">new</span><span class="x">(</span><span class="n">rule</span><span class="x">,</span> <span class="n">cells</span><span class="x">,</span> <span class="n">colorstops</span><span class="x">,</span> <span class="n">ruleset</span><span class="x">,</span> <span class="n">generation</span><span class="x">)</span>
    <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>The <code class="highlighter-rouge">cells</code> array can hold trues or falses. The <code class="highlighter-rouge">colorstops</code> array is eventually going to hold some color information. The middle cell is seeded with a single starter value.</p>

<p>The <code class="highlighter-rouge">binary_to_array()</code> function just converts a binary number to a bit array (I suspect there’s a quicker way).</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="k">function</span><span class="nf"> binary_to_array</span><span class="x">(</span><span class="n">n</span><span class="x">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">BitArray</span><span class="x">{</span><span class="mi">1</span><span class="x">}()</span>
    <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="mi">7</span><span class="x">:</span><span class="o">-</span><span class="mi">1</span><span class="x">:</span><span class="mi">0</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">c</span>
        <span class="n">push!</span><span class="x">(</span><span class="n">a</span><span class="x">,</span> <span class="x">(</span><span class="n">k</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">true</span> <span class="x">:</span> <span class="n">false</span><span class="x">))</span>
    <span class="k">end</span>
    <span class="k">return</span> <span class="n">a</span>
<span class="k">end</span></code></pre></figure>

<p>The <code class="highlighter-rouge">rules()</code> function takes the values of an individual and its neighbours and applies the rule that determines its state for the next generation:</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="k">function</span><span class="nf"> rules</span><span class="x">(</span><span class="n">ca</span><span class="o">::</span><span class="n">CA</span><span class="x">,</span> <span class="n">a</span><span class="x">,</span> <span class="n">b</span><span class="x">,</span> <span class="n">c</span><span class="x">)</span>
    <span class="n">lng</span> <span class="o">=</span> <span class="n">length</span><span class="x">(</span><span class="n">ca</span><span class="o">.</span><span class="n">ruleset</span><span class="x">)</span>
    <span class="k">return</span> <span class="n">ca</span><span class="o">.</span><span class="n">ruleset</span><span class="x">[</span><span class="n">mod1</span><span class="x">(</span><span class="n">lng</span> <span class="o">-</span> <span class="x">(</span><span class="mi">4</span><span class="n">a</span> <span class="o">+</span> <span class="mi">2</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="x">),</span> <span class="n">lng</span><span class="x">)]</span>
<span class="k">end</span></code></pre></figure>

<p>And a <code class="highlighter-rouge">nextgeneration()</code> function applies the rule to all the cells. I decided to make it wrap around, so that the final cell considers the first cell as one of its neighbours.</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="k">function</span><span class="nf"> nextgeneration</span><span class="x">(</span><span class="n">ca</span><span class="o">::</span><span class="n">CA</span><span class="x">)</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">length</span><span class="x">(</span><span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">)</span>
    <span class="n">nextgen</span> <span class="o">=</span> <span class="n">falses</span><span class="x">(</span><span class="n">l</span><span class="x">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="x">:</span><span class="n">l</span>
        <span class="n">left</span>   <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">[</span><span class="n">mod1</span><span class="x">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="x">,</span> <span class="n">l</span><span class="x">)]</span>
        <span class="n">me</span>     <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">[</span><span class="n">mod1</span><span class="x">(</span><span class="n">i</span><span class="x">,</span> <span class="n">l</span><span class="x">)]</span>
        <span class="n">right</span>  <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">[</span><span class="n">mod1</span><span class="x">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="x">,</span> <span class="n">l</span><span class="x">)]</span>
        <span class="n">nextgen</span><span class="x">[</span><span class="n">i</span><span class="x">]</span> <span class="o">=</span> <span class="n">rules</span><span class="x">(</span><span class="n">ca</span><span class="x">,</span> <span class="n">left</span><span class="x">,</span> <span class="n">me</span><span class="x">,</span> <span class="n">right</span><span class="x">)</span>
    <span class="k">end</span>
    <span class="n">ca</span><span class="o">.</span><span class="n">cells</span> <span class="o">=</span> <span class="n">nextgen</span>
    <span class="n">ca</span><span class="o">.</span><span class="n">generation</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">ca</span>
<span class="k">end</span></code></pre></figure>

<p>We’ll also teach Julia how to show an automaton in the terminal:</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="n">Base</span><span class="o">.</span><span class="n">show</span><span class="x">(</span><span class="n">io</span><span class="o">::</span><span class="n">IO</span><span class="x">,</span> <span class="o">::</span><span class="n">MIME</span><span class="s">"text/plain"</span><span class="x">,</span> <span class="n">ca</span><span class="o">::</span><span class="n">CA</span><span class="x">)</span> <span class="o">=</span>
    <span class="n">print</span><span class="x">(</span><span class="n">io</span><span class="x">,</span> <span class="n">join</span><span class="x">([</span><span class="n">c</span> <span class="o">?</span> <span class="s">"■"</span> <span class="x">:</span> <span class="s">" "</span> <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">]))</span></code></pre></figure>

<p>So now we can create a cellular automaton by providing a rule number (using the default of 100 cells):</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="n">ca</span> <span class="o">=</span> <span class="n">CA</span><span class="x">(</span><span class="mi">30</span><span class="x">)</span></code></pre></figure>

<p>update the automaton like this:</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="n">nextgeneration</span><span class="x">(</span><span class="n">ca</span><span class="x">)</span></code></pre></figure>

<p>and show a historical diagram of its evolution:</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="x">:</span><span class="mi">30</span>
    <span class="n">display</span><span class="x">(</span><span class="n">nextgeneration</span><span class="x">(</span><span class="n">ca</span><span class="x">))</span>
<span class="k">end</span></code></pre></figure>

<p><img src="/images/automata/terminal-output.png" alt="image label" /></p>

<h3 id="some-graphics">Some graphics</h3>

<p>The REPL display is more or less functional, but I want to play with the graphic output, so (you guessed):</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="n">using</span> <span class="n">Luxor</span><span class="x">,</span> <span class="n">Colors</span>

<span class="k">function</span><span class="nf"> draw</span><span class="x">(</span><span class="n">ca</span><span class="o">::</span><span class="n">CA</span><span class="x">,</span> <span class="n">cellwidth</span><span class="o">=</span><span class="mi">10</span><span class="x">)</span>
    <span class="n">lng</span> <span class="o">=</span> <span class="n">length</span><span class="x">(</span><span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="x">:</span><span class="n">lng</span>
        <span class="k">if</span> <span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">[</span><span class="n">i</span><span class="x">]</span> <span class="o">==</span> <span class="n">true</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">Point</span><span class="x">(</span><span class="o">-</span><span class="x">(</span><span class="n">lng</span> <span class="n">÷</span> <span class="mi">2</span><span class="x">)</span> <span class="o">*</span> <span class="n">cellwidth</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">cellwidth</span><span class="x">,</span> <span class="mi">0</span><span class="x">)</span>
            <span class="n">box</span><span class="x">(</span><span class="n">pt</span><span class="x">,</span> <span class="n">cellwidth</span><span class="x">,</span> <span class="n">cellwidth</span><span class="x">,</span> <span class="x">:</span><span class="n">fill</span><span class="x">)</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="nd">@png</span> <span class="n">begin</span>
    <span class="n">ca</span> <span class="o">=</span> <span class="n">CA</span><span class="x">(</span><span class="mi">30</span><span class="x">,</span> <span class="mi">200</span><span class="x">)</span>
    <span class="n">sidelength</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="c"># start at the top</span>
    <span class="n">translate</span><span class="x">(</span><span class="n">boxtopcenter</span><span class="x">(</span><span class="n">BoundingBox</span><span class="x">())</span> <span class="o">+</span> <span class="n">sidelength</span><span class="x">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="x">:</span><span class="mi">200</span>
        <span class="n">draw</span><span class="x">(</span><span class="n">ca</span><span class="x">,</span> <span class="n">sidelength</span><span class="x">)</span>
        <span class="n">nextgeneration</span><span class="x">(</span><span class="n">ca</span><span class="x">)</span>
        <span class="n">translate</span><span class="x">(</span><span class="n">Point</span><span class="x">(</span><span class="mi">0</span><span class="x">,</span> <span class="n">sidelength</span><span class="x">))</span>
    <span class="k">end</span>
<span class="k">end</span> <span class="mi">800</span> <span class="mi">850</span> <span class="s">"images/automata/simple-ca.png"</span></code></pre></figure>

<p><img src="/images/automata/simple-ca.png" alt="image label" /></p>

<p>You can call <code class="highlighter-rouge">nextgeneration()</code> without displaying the results, of course. This lets you jump into the future history of an automaton at warp speed.</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="nd">@png</span> <span class="n">begin</span>
    <span class="n">ca</span> <span class="o">=</span> <span class="n">CA</span><span class="x">(</span><span class="mi">110</span><span class="x">,</span> <span class="mi">200</span><span class="x">)</span>
    <span class="n">translate</span><span class="x">(</span><span class="n">boxtopcenter</span><span class="x">(</span><span class="n">BoundingBox</span><span class="x">())</span> <span class="o">+</span> <span class="n">sidelength</span><span class="x">)</span>
    <span class="n">sidelength</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="c"># into the future</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">1</span><span class="x">:</span><span class="mi">200_000</span>
        <span class="n">nextgeneration</span><span class="x">(</span><span class="n">ca</span><span class="x">)</span>
    <span class="k">end</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">1</span><span class="x">:</span><span class="mi">195</span>
        <span class="n">draw</span><span class="x">(</span><span class="n">ca</span><span class="x">,</span> <span class="n">sidelength</span><span class="x">)</span>
        <span class="n">nextgeneration</span><span class="x">(</span><span class="n">ca</span><span class="x">)</span>
        <span class="n">translate</span><span class="x">(</span><span class="n">Point</span><span class="x">(</span><span class="mi">0</span><span class="x">,</span> <span class="n">sidelength</span><span class="x">))</span>
    <span class="k">end</span>
<span class="k">end</span> <span class="mi">800</span> <span class="mi">800</span> <span class="s">"images/automata/simple-ca-future.png"</span></code></pre></figure>

<p><img src="/images/automata/simple-ca-future.png" alt="image label" /></p>

<p>I found that sometimes drawing them from left to right looked better (like videos recorded on phones…?):</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="nd">@png</span> <span class="n">begin</span>
    <span class="n">ca</span> <span class="o">=</span> <span class="n">CA</span><span class="x">(</span><span class="mi">30</span><span class="x">)</span>
    <span class="n">translate</span><span class="x">(</span><span class="n">boxmiddleleft</span><span class="x">(</span><span class="n">BoundingBox</span><span class="x">())</span> <span class="o">+</span> <span class="n">sidelength</span><span class="x">)</span>
    <span class="n">rotate</span><span class="x">(</span><span class="o">-</span><span class="n">π</span><span class="o">/</span><span class="mi">2</span><span class="x">)</span>
    <span class="n">sidelength</span> <span class="o">=</span> <span class="mf">3.5</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="x">:</span><span class="mi">320</span>
        <span class="n">draw</span><span class="x">(</span><span class="n">ca</span><span class="x">,</span> <span class="n">sidelength</span><span class="x">)</span>
        <span class="n">nextgeneration</span><span class="x">(</span><span class="n">ca</span><span class="x">)</span>
        <span class="n">translate</span><span class="x">(</span><span class="n">Point</span><span class="x">(</span><span class="mi">0</span><span class="x">,</span> <span class="n">sidelength</span><span class="x">))</span>
    <span class="k">end</span>
<span class="k">end</span> <span class="mi">1000</span> <span class="mi">400</span> <span class="s">"images/automata/simple-landscape-ca.png"</span></code></pre></figure>

<p><img src="/images/automata/simple-landscape-ca.png" alt="image label" /></p>

<h3 id="and-now-in-color">And now in color</h3>

<p>So far I haven’t used the color information that’s stored.</p>

<p>The <code class="highlighter-rouge">nextgeneration()</code> function can be updated with instructions about how to modify the color of the next generation, based on the current set of three cells.</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="k">function</span><span class="nf"> nextgeneration</span><span class="x">(</span><span class="n">ca</span><span class="o">::</span><span class="n">CA</span><span class="x">)</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">length</span><span class="x">(</span><span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">)</span>
    <span class="n">nextgen</span> <span class="o">=</span> <span class="n">falses</span><span class="x">(</span><span class="n">l</span><span class="x">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="x">:</span><span class="n">l</span>
        <span class="n">left</span>   <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">[</span><span class="n">mod1</span><span class="x">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="x">,</span> <span class="n">l</span><span class="x">)]</span>
        <span class="n">me</span>     <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">[</span><span class="n">mod1</span><span class="x">(</span><span class="n">i</span><span class="x">,</span> <span class="n">l</span><span class="x">)]</span>
        <span class="n">right</span>  <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">[</span><span class="n">mod1</span><span class="x">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="x">,</span> <span class="n">l</span><span class="x">)]</span>
        <span class="n">nextgen</span><span class="x">[</span><span class="n">i</span><span class="x">]</span> <span class="o">=</span> <span class="n">rules</span><span class="x">(</span><span class="n">ca</span><span class="x">,</span> <span class="n">left</span><span class="x">,</span> <span class="n">me</span><span class="x">,</span> <span class="n">right</span><span class="x">)</span>
        <span class="k">if</span> <span class="n">me</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">ca</span><span class="o">.</span><span class="n">colorstops</span><span class="x">[</span><span class="n">i</span><span class="x">]</span> <span class="o">=</span> <span class="n">mod</span><span class="x">(</span><span class="n">ca</span><span class="o">.</span><span class="n">colorstops</span><span class="x">[</span><span class="n">i</span><span class="x">]</span> <span class="o">+</span> <span class="mf">0.1</span><span class="x">,</span> <span class="mi">1</span><span class="x">)</span>
        <span class="k">elseif</span> <span class="n">left</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">ca</span><span class="o">.</span><span class="n">colorstops</span><span class="x">[</span><span class="n">i</span><span class="x">]</span> <span class="o">=</span> <span class="n">mod</span><span class="x">(</span><span class="n">ca</span><span class="o">.</span><span class="n">colorstops</span><span class="x">[</span><span class="n">i</span><span class="x">]</span> <span class="o">-</span> <span class="mf">0.1</span><span class="x">,</span> <span class="mi">1</span><span class="x">)</span>
        <span class="k">else</span>
            <span class="n">ca</span><span class="o">.</span><span class="n">colorstops</span><span class="x">[</span><span class="n">i</span><span class="x">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">end</span>
    <span class="k">end</span>
    <span class="n">ca</span><span class="o">.</span><span class="n">cells</span> <span class="o">=</span> <span class="n">nextgen</span>
    <span class="n">ca</span><span class="o">.</span><span class="n">generation</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">ca</span>
<span class="k">end</span></code></pre></figure>

<p>and the <code class="highlighter-rouge">draw()</code> function can be adapted to make use of the color information. I decided to avoid tackling RGB color value transformations for a first pass, so the single value between 0 and 1 is used to select a color from a color map.</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="n">using</span> <span class="n">ColorSchemes</span>

<span class="k">function</span><span class="nf"> drawcolor</span><span class="x">(</span><span class="n">ca</span><span class="o">::</span><span class="n">CA</span><span class="x">,</span> <span class="n">cellwidth</span><span class="o">=</span><span class="mi">10</span><span class="x">;</span>
        <span class="n">scheme</span><span class="o">=</span><span class="n">ColorSchemes</span><span class="o">.</span><span class="n">leonardo</span><span class="x">)</span>
    <span class="n">lng</span> <span class="o">=</span> <span class="n">length</span><span class="x">(</span><span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="x">:</span><span class="n">lng</span>
        <span class="k">if</span> <span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">[</span><span class="n">i</span><span class="x">]</span> <span class="o">==</span> <span class="n">true</span>
            <span class="n">sethue</span><span class="x">(</span><span class="n">get</span><span class="x">(</span><span class="n">scheme</span><span class="x">,</span> <span class="n">ca</span><span class="o">.</span><span class="n">colorstops</span><span class="x">[</span><span class="n">i</span><span class="x">]))</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">Point</span><span class="x">(</span><span class="o">-</span><span class="x">(</span><span class="n">lng</span> <span class="n">÷</span> <span class="mi">2</span><span class="x">)</span> <span class="o">*</span> <span class="n">cellwidth</span> <span class="o">+</span> <span class="x">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">cellwidth</span><span class="x">),</span> <span class="mi">0</span><span class="x">)</span>
            <span class="n">box</span><span class="x">(</span><span class="n">pt</span><span class="x">,</span> <span class="n">cellwidth</span><span class="x">,</span> <span class="n">cellwidth</span><span class="x">,</span> <span class="x">:</span><span class="n">fill</span><span class="x">)</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="nd">@svg</span> <span class="n">begin</span>
    <span class="n">background</span><span class="x">(</span><span class="s">"darkorchid4"</span><span class="x">)</span>
    <span class="n">ca</span> <span class="o">=</span> <span class="n">CA</span><span class="x">(</span><span class="mi">135</span><span class="x">,</span> <span class="mi">65</span><span class="x">)</span>
    <span class="c"># randomize start state</span>
    <span class="n">ca</span><span class="o">.</span><span class="n">cells</span> <span class="o">=</span> <span class="n">rand</span><span class="x">(</span><span class="kt">Bool</span><span class="x">,</span> <span class="n">length</span><span class="x">(</span><span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">))</span>
    <span class="n">sidelength</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">translate</span><span class="x">(</span><span class="n">boxmiddleleft</span><span class="x">(</span><span class="n">BoundingBox</span><span class="x">())</span> <span class="o">+</span> <span class="n">sidelength</span><span class="x">)</span>
    <span class="n">rotate</span><span class="x">(</span><span class="o">-</span><span class="n">π</span><span class="o">/</span><span class="mi">2</span><span class="x">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="x">:</span><span class="mi">195</span>
        <span class="n">drawcolor</span><span class="x">(</span><span class="n">ca</span><span class="x">,</span> <span class="n">sidelength</span><span class="x">,</span> <span class="n">scheme</span><span class="o">=</span><span class="n">ColorSchemes</span><span class="o">.</span><span class="n">cubehelix</span><span class="x">)</span>
        <span class="n">nextgeneration</span><span class="x">(</span><span class="n">ca</span><span class="x">)</span>
        <span class="n">translate</span><span class="x">(</span><span class="n">Point</span><span class="x">(</span><span class="mi">0</span><span class="x">,</span> <span class="n">sidelength</span><span class="x">))</span>
    <span class="k">end</span>
<span class="k">end</span> <span class="mi">1000</span> <span class="mi">400</span> <span class="s">"images/automata/simple-color-ca.svg"</span></code></pre></figure>

<p><img src="/images/automata/simple-color-ca.svg" alt="image label" /></p>

<p>This could lead to hours of entertainment (depending on your definition of fun, of course). I uploaded a few experiments that didn’t turn out too badly <a href="https://www.flickr.com/photos/153311384@N03/" target="_blank">on Flickr</a>. The current rules show a kind of literal winning streak, as a cell that remains occupied for many generations ends up being brightly illuminated.</p>

<p>I think these images look quite good when scaled up. It only takes about a second to draw these, but would take much longer to stick them on the wall:</p>

<p><img src="/images/automata/office-layout-1.png" alt="image label" /></p>

<p><img src="/images/automata/office-layout-2.png" alt="image label" /></p>

<p>The rules for specifying a change in color could do with some kind of systematic definition, perhaps, such that, say, “rule C81” means “increase colorstop by amount if previous parent is 1, decrease it if previous uncle-aunt is 1”, and so on. Then you could pass a set of color rules to the drawing function. (<em>uncle-aunt</em>? I couldn’t find a word for something that is either an uncle or an aunt, but not a parent…)</p>

<p>Instead of drawing simple squares, it’s possible to draw other shapes. I’m quite fond of the squircle — you can change the <code class="highlighter-rouge">rt</code> parameter to get different shapes:</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="k">function</span><span class="nf"> drawcolorsquircle</span><span class="x">(</span><span class="n">ca</span><span class="o">::</span><span class="n">CA</span><span class="x">,</span> <span class="n">cellwidth</span><span class="o">=</span><span class="mi">10</span><span class="x">;</span>
        <span class="n">scheme</span><span class="o">=</span><span class="n">ColorSchemes</span><span class="o">.</span><span class="n">leonardo</span><span class="x">)</span>
    <span class="n">lng</span> <span class="o">=</span> <span class="n">length</span><span class="x">(</span><span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="x">:</span><span class="n">lng</span>
        <span class="k">if</span> <span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">[</span><span class="n">i</span><span class="x">]</span> <span class="o">==</span> <span class="n">true</span>
            <span class="n">sethue</span><span class="x">(</span><span class="n">get</span><span class="x">(</span><span class="n">scheme</span><span class="x">,</span> <span class="n">ca</span><span class="o">.</span><span class="n">colorstops</span><span class="x">[</span><span class="n">i</span><span class="x">]))</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">Point</span><span class="x">(</span><span class="o">-</span><span class="x">(</span><span class="n">lng</span> <span class="n">÷</span> <span class="mi">2</span><span class="x">)</span> <span class="o">*</span> <span class="n">cellwidth</span> <span class="o">+</span> <span class="x">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">cellwidth</span><span class="x">),</span> <span class="mi">0</span><span class="x">)</span>
            <span class="n">squircle</span><span class="x">(</span><span class="n">pt</span><span class="x">,</span> <span class="n">cellwidth</span><span class="x">,</span> <span class="n">cellwidth</span><span class="x">,</span> <span class="n">rt</span><span class="o">=</span><span class="mf">6.0</span><span class="x">,</span> <span class="x">:</span><span class="n">fill</span><span class="x">)</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="nd">@svg</span> <span class="n">begin</span>
    <span class="n">background</span><span class="x">(</span><span class="s">"navyblue"</span><span class="x">)</span>
    <span class="n">ca</span> <span class="o">=</span> <span class="n">CA</span><span class="x">(</span><span class="mi">110</span><span class="x">,</span> <span class="mi">30</span><span class="x">)</span>
    <span class="c"># randomize start state</span>
    <span class="n">ca</span><span class="o">.</span><span class="n">cells</span> <span class="o">=</span> <span class="n">rand</span><span class="x">(</span><span class="kt">Bool</span><span class="x">,</span> <span class="n">length</span><span class="x">(</span><span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">))</span>
    <span class="n">translate</span><span class="x">(</span><span class="n">boxmiddleleft</span><span class="x">(</span><span class="n">BoundingBox</span><span class="x">())</span> <span class="o">+</span> <span class="n">sidelength</span><span class="x">)</span>
    <span class="n">rotate</span><span class="x">(</span><span class="o">-</span><span class="n">π</span><span class="o">/</span><span class="mi">2</span><span class="x">)</span>
    <span class="n">sidelength</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="x">:</span><span class="mi">100</span>
        <span class="n">drawcolorsquircle</span><span class="x">(</span><span class="n">ca</span><span class="x">,</span> <span class="n">sidelength</span><span class="x">,</span> <span class="n">scheme</span><span class="o">=</span><span class="n">ColorSchemes</span><span class="o">.</span><span class="n">Dark2_8</span><span class="x">)</span>
        <span class="n">nextgeneration</span><span class="x">(</span><span class="n">ca</span><span class="x">)</span>
        <span class="n">translate</span><span class="x">(</span><span class="n">Point</span><span class="x">(</span><span class="mi">0</span><span class="x">,</span> <span class="n">sidelength</span><span class="x">))</span>
    <span class="k">end</span>
<span class="k">end</span> <span class="mi">1000</span> <span class="mi">400</span> <span class="s">"images/automata/simple-color-ca-squircle.svg"</span></code></pre></figure>

<p><img src="/images/automata/simple-color-ca-squircle.svg" alt="image label" /></p>

<p>(This SVG is quite big, and won’t display in Juno. But it should load in a browser.)</p>

<h3 id="getting-around-to-it">Getting around to it</h3>

<p>It occurred to me that you could take a rectangular array and wrap it into a circle.</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="k">function</span><span class="nf"> drawsector</span><span class="x">(</span><span class="n">ca</span><span class="o">::</span><span class="n">CA</span><span class="x">,</span> <span class="n">cellwidth</span><span class="o">=</span><span class="mi">10</span><span class="x">;</span>
        <span class="n">scheme</span><span class="o">=</span><span class="n">ColorSchemes</span><span class="o">.</span><span class="n">leonardo</span><span class="x">,</span>
        <span class="n">centralradius</span> <span class="o">=</span> <span class="mi">10</span><span class="x">)</span>
    <span class="n">lng</span> <span class="o">=</span> <span class="n">length</span><span class="x">(</span><span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">)</span>
    <span class="n">width</span> <span class="o">=</span> <span class="n">lng</span> <span class="o">*</span> <span class="n">cellwidth</span>
    <span class="n">angulargap</span> <span class="o">=</span> <span class="mi">2</span><span class="n">π</span><span class="o">/</span><span class="n">lng</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="x">:</span><span class="n">lng</span>
        <span class="n">sethue</span><span class="x">(</span><span class="n">get</span><span class="x">(</span><span class="n">scheme</span><span class="x">,</span> <span class="n">ca</span><span class="o">.</span><span class="n">colorstops</span><span class="x">[</span><span class="n">i</span><span class="x">]))</span>
        <span class="n">innerradius</span> <span class="o">=</span> <span class="n">centralradius</span>
        <span class="n">outerradius</span> <span class="o">=</span> <span class="n">centralradius</span> <span class="o">+</span> <span class="n">cellwidth</span>
        <span class="n">startang</span>    <span class="o">=</span> <span class="n">rescale</span><span class="x">(</span><span class="n">i</span><span class="x">,</span> <span class="mi">1</span><span class="x">,</span> <span class="n">lng</span><span class="x">,</span> <span class="mi">0</span><span class="x">,</span> <span class="mi">2</span><span class="n">π</span><span class="x">)</span>
        <span class="n">endang</span>      <span class="o">=</span> <span class="n">startang</span> <span class="o">+</span> <span class="n">angulargap</span>
        <span class="k">if</span> <span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">[</span><span class="n">i</span><span class="x">]</span> <span class="o">==</span> <span class="n">true</span>
            <span class="n">sector</span><span class="x">(</span><span class="n">O</span><span class="x">,</span> <span class="n">innerradius</span><span class="x">,</span> <span class="n">outerradius</span><span class="x">,</span> <span class="n">startang</span><span class="x">,</span> <span class="n">endang</span><span class="x">,</span> <span class="x">:</span><span class="n">fillstroke</span><span class="x">)</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="k">function</span><span class="nf"> drawrule</span><span class="x">(</span><span class="n">rulenumber</span><span class="x">,</span> <span class="n">pos</span><span class="x">)</span>
    <span class="nd">@layer</span> <span class="n">begin</span>
        <span class="n">translate</span><span class="x">(</span><span class="n">pos</span><span class="x">)</span>
        <span class="n">sethue</span><span class="x">(</span><span class="s">"black"</span><span class="x">)</span>
        <span class="n">text</span><span class="x">(</span><span class="n">string</span><span class="x">(</span><span class="n">rulenumber</span><span class="x">),</span> <span class="n">halign</span><span class="o">=</span><span class="x">:</span><span class="n">center</span><span class="x">,</span> <span class="n">valign</span><span class="o">=</span><span class="x">:</span><span class="n">middle</span><span class="x">)</span>
        <span class="n">rotate</span><span class="x">(</span><span class="o">-</span><span class="n">π</span><span class="o">/</span><span class="mi">2</span><span class="x">)</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="n">CA</span><span class="x">(</span><span class="n">rulenumber</span><span class="x">,</span> <span class="mi">50</span><span class="x">)</span>
        <span class="c"># randomize start state</span>
        <span class="c"># ca.cells = rand(Bool, length(ca.cells))</span>
        <span class="n">sidelength</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">setline</span><span class="x">(</span><span class="mf">0.0</span><span class="x">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="k">in</span> <span class="mi">5</span><span class="x">:</span><span class="n">sidelength</span><span class="x">:</span><span class="mi">30</span>
            <span class="n">drawsector</span><span class="x">(</span><span class="n">ca</span><span class="x">,</span> <span class="n">sidelength</span><span class="x">,</span>
            <span class="n">scheme</span><span class="o">=</span><span class="n">ColorSchemes</span><span class="o">.</span><span class="n">klimt</span><span class="x">,</span>
            <span class="n">centralradius</span> <span class="o">=</span> <span class="n">n</span><span class="x">)</span>
            <span class="n">nextgeneration</span><span class="x">(</span><span class="n">ca</span><span class="x">)</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>This shows all the rules in this circular form.</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="n">let</span>
    <span class="c"># best in SVG or PDF, but PNG is faster</span>
    <span class="n">Drawing</span><span class="x">(</span><span class="mi">1200</span><span class="x">,</span> <span class="mi">1200</span><span class="x">,</span> <span class="s">"images/automata/color-sector-assembly.svg"</span><span class="x">)</span>
    <span class="n">origin</span><span class="x">()</span>
    <span class="n">background</span><span class="x">(</span><span class="s">"azure"</span><span class="x">)</span>
    <span class="n">fontsize</span><span class="x">(</span><span class="mi">8</span><span class="x">)</span>
    <span class="k">for</span> <span class="x">(</span><span class="n">pos</span><span class="x">,</span> <span class="n">n</span><span class="x">)</span> <span class="k">in</span> <span class="n">Tiler</span><span class="x">(</span><span class="mi">1200</span><span class="x">,</span> <span class="mi">1200</span><span class="x">,</span> <span class="mi">16</span><span class="x">,</span> <span class="mi">16</span><span class="x">)</span>
        <span class="n">drawrule</span><span class="x">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="x">,</span> <span class="n">pos</span><span class="x">)</span>
    <span class="k">end</span>
    <span class="n">finish</span><span class="x">()</span>
    <span class="n">preview</span><span class="x">()</span>
<span class="k">end</span></code></pre></figure>

<p><img src="/images/automata/color-sector-assembly.svg" alt="image label" /></p>

<p>(Again, this image is quite demanding for SVG and can take a while to load, even though it doesn’t take long to generate.)</p>

<p>After playing with this idea, I thought it would make some nice jewellery:</p>

<p><img src="/images/automata/ca-jewellery-like.png" alt="image label" /></p>

<p>This is rule 150. I mapped the array to a semicircle and drew it twice.</p>

<h3 id="and-it-moves">And it moves</h3>

<p>Many of the rules have limited career paths. Some fizzle out very quickly, others settle down into a stable if repetitive life style. There are a few that continue to make patterns as the number of generations heads off into the thousands.</p>

<p>The unpredictable high achiever of the 1D cellular automata world is Rule 110. The rule itself is so simple, it could have been described in a Shakespeare play:</p>

<blockquote>
  <p>[Enter HAMLET, stage left.]</p>

  <p>For Zeros become Ones at all positions,</p>

  <p>Where the value to the right is One.</p>

  <p>Yet Ones are changed to Zeros where’er</p>

  <p>The values to left and right are One.</p>
</blockquote>

<p>And yet this simple rule has been the subject of an astonishing amount of analysis, such as <a href="http://uncomp.uwe.ac.uk/genaro/Papers/Papers_on_CA_files/MARTINEZ.pdf" target="_blank">this in-depth paper by Martinez et al</a> published in the wonderfully-named <em>International Journal of Unconventional Computing</em>. <a href="https://arxiv.org/pdf/0906.3248v1.pdf" target="_blank">Matthew Cook’s famous paper</a> proved that Rule 110 is capable of emulating the activity of a Turing machine.</p>

<p>I understood very little of those wonderful papers, but they did make me want to at least see Rule 110 in action, just in case I could spot all those <em>cyclic tags</em>, <em>meta-gliders</em>, and <em>pseudo-solitons</em>.</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="k">function</span><span class="nf"> frame</span><span class="x">(</span><span class="n">scene</span><span class="x">,</span> <span class="n">framenumber</span><span class="x">,</span> <span class="n">ca</span><span class="x">,</span> <span class="n">cahistory</span><span class="x">,</span> <span class="n">sidelength</span><span class="x">;</span>
            <span class="n">smoothscrolling</span><span class="o">=</span><span class="mi">10</span><span class="x">)</span>
    <span class="n">background</span><span class="x">(</span><span class="n">colorant</span><span class="s">"navy"</span><span class="x">)</span>
    <span class="n">fontsize</span><span class="x">(</span><span class="mi">12</span><span class="x">)</span>
    <span class="n">sethue</span><span class="x">(</span><span class="n">colorant</span><span class="s">"azure"</span><span class="x">)</span>
    <span class="n">text</span><span class="x">(</span><span class="n">string</span><span class="x">(</span><span class="n">ca</span><span class="o">.</span><span class="n">generation</span><span class="x">),</span> <span class="n">boxtopright</span><span class="x">(</span><span class="n">BoundingBox</span><span class="x">())</span> <span class="o">+</span> <span class="x">(</span><span class="o">-</span><span class="mi">30</span><span class="x">,</span> <span class="mi">20</span><span class="x">),</span>
        <span class="n">halign</span><span class="o">=</span><span class="x">:</span><span class="n">right</span><span class="x">)</span>
    <span class="n">setline</span><span class="x">(</span><span class="mf">0.1</span><span class="x">)</span>

    <span class="c"># get in position for the first row</span>
    <span class="n">translate</span><span class="x">(</span><span class="n">boxmiddleleft</span><span class="x">(</span><span class="n">BoundingBox</span><span class="x">()))</span>
    <span class="n">rotate</span><span class="x">(</span><span class="o">-</span><span class="n">π</span><span class="o">/</span><span class="mi">2</span><span class="x">)</span>

    <span class="c"># for smooth scrolling</span>
    <span class="n">translate</span><span class="x">(</span><span class="mi">0</span><span class="x">,</span> <span class="o">-</span><span class="x">(</span><span class="n">mod1</span><span class="x">(</span><span class="n">framenumber</span><span class="x">,</span> <span class="n">smoothscrolling</span><span class="x">))</span>
        <span class="o">*</span> <span class="n">sidelength</span><span class="o">/</span><span class="n">smoothscrolling</span><span class="x">)</span>

    <span class="n">lng</span> <span class="o">=</span> <span class="n">length</span><span class="x">(</span><span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">)</span>
    <span class="k">for</span> <span class="n">gen</span> <span class="k">in</span> <span class="n">cahistory</span>
        <span class="k">for</span> <span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">cell</span><span class="x">)</span> <span class="k">in</span> <span class="n">enumerate</span><span class="x">(</span><span class="n">gen</span><span class="x">)</span>
            <span class="k">if</span> <span class="n">cell</span> <span class="o">==</span> <span class="n">true</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="n">Point</span><span class="x">(</span><span class="o">-</span><span class="x">(</span><span class="n">lng</span> <span class="o">/</span> <span class="mi">2</span><span class="x">)</span> <span class="o">*</span> <span class="n">sidelength</span> <span class="o">+</span> <span class="x">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">sidelength</span><span class="x">),</span> <span class="mi">0</span><span class="x">)</span>
                <span class="n">box</span><span class="x">(</span><span class="n">pt</span><span class="x">,</span> <span class="n">sidelength</span> <span class="o">-</span> <span class="mi">2</span><span class="x">,</span> <span class="n">sidelength</span> <span class="o">-</span> <span class="mi">2</span><span class="x">,</span> <span class="x">:</span><span class="n">fill</span><span class="x">)</span>
            <span class="k">end</span>
        <span class="k">end</span>
        <span class="n">translate</span><span class="x">(</span><span class="n">Point</span><span class="x">(</span><span class="mi">0</span><span class="x">,</span> <span class="n">sidelength</span><span class="x">))</span>
    <span class="k">end</span>
    <span class="c"># "beautiful buttery scrolling"</span>
    <span class="k">if</span> <span class="n">framenumber</span> <span class="o">%</span> <span class="n">smoothscrolling</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="c"># drop oldest, add a new generation</span>
        <span class="n">popfirst!</span><span class="x">(</span><span class="n">cahistory</span><span class="x">)</span>
        <span class="n">nextgeneration</span><span class="x">(</span><span class="n">ca</span><span class="x">)</span>
        <span class="n">push!</span><span class="x">(</span><span class="n">cahistory</span><span class="x">,</span> <span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">)</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="k">function</span><span class="nf"> makeanimation</span><span class="x">(</span><span class="n">rule</span><span class="x">,</span> <span class="n">filename</span><span class="x">)</span>
    <span class="n">width</span><span class="x">,</span> <span class="n">height</span> <span class="o">=</span> <span class="x">(</span><span class="mi">1920</span><span class="x">,</span> <span class="mi">1080</span><span class="x">)</span>
    <span class="n">sidelength</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">cellularmovie</span> <span class="o">=</span> <span class="n">Movie</span><span class="x">(</span><span class="n">width</span><span class="x">,</span> <span class="n">height</span><span class="x">,</span> <span class="s">"cellularmovie"</span><span class="x">)</span>
    <span class="n">ca</span> <span class="o">=</span> <span class="n">CA</span><span class="x">(</span><span class="n">rule</span><span class="x">,</span> <span class="nb">convert</span><span class="x">(</span><span class="kt">Int</span><span class="x">,</span> <span class="n">height÷sidelength</span><span class="x">))</span>
    <span class="n">cahistory</span> <span class="o">=</span> <span class="x">[]</span>
    <span class="c"># initial</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">1</span><span class="x">:</span><span class="n">width÷sidelength</span>
        <span class="n">push!</span><span class="x">(</span><span class="n">cahistory</span><span class="x">,</span> <span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">)</span>
        <span class="n">nextgeneration</span><span class="x">(</span><span class="n">ca</span><span class="x">)</span>
    <span class="k">end</span>
    <span class="n">animate</span><span class="x">(</span><span class="n">cellularmovie</span><span class="x">,</span>
        <span class="x">[</span><span class="n">Scene</span><span class="x">(</span><span class="n">cellularmovie</span><span class="x">,</span> <span class="x">(</span><span class="n">s</span><span class="x">,</span> <span class="n">f</span><span class="x">)</span> <span class="o">-&gt;</span>
            <span class="n">frame</span><span class="x">(</span><span class="n">s</span><span class="x">,</span> <span class="n">f</span><span class="x">,</span> <span class="n">ca</span><span class="x">,</span> <span class="n">cahistory</span><span class="x">,</span> <span class="n">sidelength</span><span class="x">,</span> <span class="n">smoothscrolling</span><span class="o">=</span><span class="mi">4</span><span class="x">),</span>
                <span class="mi">1</span><span class="x">:</span><span class="mi">500</span><span class="x">)],</span>
    <span class="n">pathname</span><span class="o">=</span><span class="s">"</span><span class="si">$(filename)</span><span class="s">"</span><span class="x">)</span>
<span class="k">end</span>

<span class="n">makeanimation</span><span class="x">(</span><span class="mi">110</span><span class="x">,</span> <span class="s">"images/automata/animated-cellular-automaton.gif"</span><span class="x">)</span></code></pre></figure>

<p><img src="/images/automata/animated-cellular-automaton.gif" alt="image label" /></p>

<p>If each frame moved the history ‘window’ by one generation, you’d get a jerky animation. The smooth-scrolling used here shifts the contents by a few pixels in each frame but changes the contents less often. This requires more frames than generations, so 300 frames with a <code class="highlighter-rouge">smoothscrolling</code> value of 10 shows only 30 new generations after the initial bunch.</p>

<p>This GIF does have a few problems; the conflicting demands of file size, image size, image quality, and scroll speed work against each other. There’s a slight flickering, due I think to the rounding or aliasing in the GIF. You could make the GIF as long as you want, subject of course to the maximum size of animated GIF that you’re prepared to handle. (And yes, this page does take a long time to load. Sorry.)</p>

<p>Videos also have their problems with this kind of content, because the downsampling commonly applied can affect the detail. To see what I mean, try watching <a href="https://www.youtube.com/watch?v=iKpIuCmATYE&amp;feature=youtu.be" target="_blank">Rule 110: The Movie</a> (on YouTube). (This is my submission for YouTube’s <em>Most Boring Video 2018</em> competition.)</p>

<h3 id="solid-work">Solid work</h3>

<p>If you want to do more than just look at pictures on the screen—perhaps you’re building your own railway station?—here are some tips for exporting the graphics to your favourite 3D modeller.</p>

<p>First, place a box or shape around the outside of the design, and use the <code class="highlighter-rouge">:path</code> action rather than <code class="highlighter-rouge">:fill</code> or <code class="highlighter-rouge">:stroke</code>. Then, to draw what are now the ‘holes’, use <code class="highlighter-rouge">newsubpath()</code> before drawing each hole, and make sure to draw the holes with reversed paths (using the <code class="highlighter-rouge">reversepath</code> keyword, for example).</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="k">function</span><span class="nf"> drawaspath</span><span class="x">(</span><span class="n">ca</span><span class="o">::</span><span class="n">CA</span><span class="x">;</span>
        <span class="n">cellwidth</span><span class="o">=</span><span class="mi">10</span><span class="x">)</span>
    <span class="n">lng</span> <span class="o">=</span> <span class="n">length</span><span class="x">(</span><span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="x">:</span><span class="n">lng</span>
        <span class="k">if</span> <span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">[</span><span class="n">i</span><span class="x">]</span> <span class="o">==</span> <span class="n">true</span>
            <span class="n">newsubpath</span><span class="x">()</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">Point</span><span class="x">(</span><span class="o">-</span><span class="x">(</span><span class="n">lng</span> <span class="n">÷</span> <span class="mi">2</span><span class="x">)</span> <span class="o">*</span> <span class="n">cellwidth</span> <span class="o">+</span> <span class="x">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">cellwidth</span><span class="x">),</span> <span class="mi">0</span><span class="x">)</span>
            <span class="n">poly</span><span class="x">(</span><span class="n">box</span><span class="x">(</span><span class="n">pt</span><span class="x">,</span> <span class="n">cellwidth</span> <span class="o">-</span> <span class="mi">2</span><span class="x">,</span> <span class="n">cellwidth</span> <span class="o">-</span> <span class="mi">2</span><span class="x">,</span> <span class="n">vertices</span><span class="o">=</span><span class="n">true</span><span class="x">),</span>
                <span class="x">:</span><span class="n">path</span><span class="x">,</span> <span class="n">reversepath</span><span class="o">=</span><span class="n">true</span><span class="x">,</span> <span class="n">close</span><span class="o">=</span><span class="n">true</span><span class="x">)</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="nd">@svg</span> <span class="n">begin</span>
    <span class="n">background</span><span class="x">(</span><span class="s">"black"</span><span class="x">)</span>
    <span class="n">ca</span> <span class="o">=</span> <span class="n">CA</span><span class="x">(</span><span class="mi">110</span><span class="x">,</span> <span class="mi">40</span><span class="x">)</span>
    <span class="n">ca</span><span class="o">.</span><span class="n">cells</span> <span class="o">=</span> <span class="n">rand</span><span class="x">(</span><span class="kt">Bool</span><span class="x">,</span> <span class="n">length</span><span class="x">(</span><span class="n">ca</span><span class="o">.</span><span class="n">cells</span><span class="x">))</span>
    <span class="n">cellwidth</span> <span class="o">=</span> <span class="mi">7</span>
    <span class="n">bxw</span> <span class="o">=</span> <span class="n">boxwidth</span><span class="x">(</span><span class="n">BoundingBox</span><span class="x">()</span> <span class="o">*</span> <span class="mf">0.98</span><span class="x">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">squircle</span><span class="x">(</span><span class="n">O</span><span class="x">,</span> <span class="n">bxw</span><span class="x">,</span> <span class="n">bxw</span><span class="x">,</span> <span class="n">rt</span><span class="o">=</span><span class="mf">0.1</span><span class="x">,</span> <span class="x">:</span><span class="n">path</span><span class="x">)</span>
    <span class="n">translate</span><span class="x">(</span><span class="n">boxtopcenter</span><span class="x">(</span><span class="n">BoundingBox</span><span class="x">())</span> <span class="o">+</span> <span class="x">(</span><span class="o">-</span><span class="mi">5</span><span class="x">,</span> <span class="mi">7</span><span class="x">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="x">:</span><span class="mi">40</span>
        <span class="n">translate</span><span class="x">(</span><span class="mi">0</span><span class="x">,</span> <span class="n">cellwidth</span><span class="x">)</span>
        <span class="n">drawaspath</span><span class="x">(</span><span class="n">ca</span><span class="x">,</span> <span class="n">cellwidth</span><span class="o">=</span><span class="n">cellwidth</span><span class="x">)</span>
        <span class="n">nextgeneration</span><span class="x">(</span><span class="n">ca</span><span class="x">)</span>
    <span class="k">end</span>
    <span class="n">sethue</span><span class="x">(</span><span class="s">"grey80"</span><span class="x">)</span>
    <span class="n">fillpath</span><span class="x">()</span>
<span class="k">end</span> <span class="mi">300</span> <span class="mi">300</span> <span class="s">"images/automata/ca-as-path.svg"</span></code></pre></figure>

<p><img src="/images/automata/ca-as-path.svg" alt="image label" class="center-image" /></p>

<p>So this is a single path, and the holes are reversed subpaths. When you import this single path into a 3D modelling program, you <em>should</em> be able to extrude it into a solid without problems. Here’s one modelled as a thin gold reflective sheet.</p>

<p><img src="/images/automata/ca-3d-render-1.png" alt="image label" /></p>

<p>It’s hard to resist playing with 3D modellers… I added some fog and a rusty metal effect:</p>

<p><img src="/images/automata/ca-3d-render-2.png" alt="image label" /></p>

<p>If you omit the surrounding path, it might still work visually. It would be a challenge to hang all these pieces on a gallery wall:</p>

<p><img src="/images/automata/ca-3d-render-3.png" alt="image label" /></p>

<p>These little critters are quite interesting, and there are a <a href="https://arxiv.org/search/?query=%22cellular+automata%22&amp;searchtype=title&amp;abstracts=show&amp;order=-announced_date_first&amp;size=50" target="_blank">fair number of scientific papers</a> with “cellular automata” in the title . I think this must be because, although things don’t get much simpler than a cellular automaton, perhaps they might—in some strange way—be similar to how the universe itself works when you zoom in close enough.</p>

<p>[2018-11-29]</p>

<p><img src="http://steampiano.net/cormullionknot.gif?automata" alt="cormullion signing off" class="center-image" /></p>

<p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>At the time of writing this I couldn’t find any working Julia packages that did one-dimensional cellular automata. But if I had found one, I probably wouldn’t have written any of the above anyway. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div><a class="u-url" href="/blog/2018/11/29/automata.html" hidden></a>
</article>

      </div>
    </main><footer>
<pre class="smallheading">comments or questions - open an issue at <a href="https://github.com/cormullion/cormullion.github.io">github.com/cormullion/</a></pre>
</footer>
</body>

</html>
